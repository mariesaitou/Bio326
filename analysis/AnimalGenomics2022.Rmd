---
title: "AnimalGenomics2022"
author: "Marie Saitou"
date: "2/20/2022"
output:
  pdf_document: default
  html_document: default
---

## Connect to Orion
Go to https://orion.nmbu.no/ at NMBU or with VPN.

![](assets/Bio326-2022/prep1.png){width=80%}

Click "Rstudio"

![](assets/Bio326-2022/prep2.png){width=80%}

Click "2 hours"


![](assets/Bio326-2022/prep3.png){width=40%}

Click "Rstudio-4.1.0"

# 0. Preparation
### Where is your personal directory? 
Set your working directory there by "setwd".
![](assets/Bio326-2022/prep4.png){width=80%}
```{r,eval=FALSE}
## You have to CHANGE "working directory" to your directory (bio326-22-XX)
setwd("/net/cn-1/mnt/SCRATCH/bio326-22-XX/") 
#setwd("/net/cn-1/mnt/SCRATCH/bio326-21/bio326_2022/AnimalGenomics/QCTutorial/")

## Install necessary libraries
install.packages("dplyr","emojifont","extrafont","ggplot2","RColorBrewer","tufte","caTools","fastmatch")

## Load libraries
library(dplyr)
library(emojifont)
library(extrafont)
library(ggplot2)
library(RColorBrewer)
library(tufte)
library(caTools)
library(fastmatch)  

# Make a result directory
dir.create("Results", showWarnings = FALSE)
```

### Set Parameters
```{r, eval=FALSE}
qcThreshold <- 7
binFilter <- 5
scaling <- 1
reportDPI <- 300

slurpContent <- function(filename) {
  setup = as.logical(tutorialText)
  if (setup) {
    paste(readLines(filename),collapse="\n")
  }
}
```

### Executive summary 
### You have to CHANGE "input file" and other info 
When you analyze another data.
```{r, eval=FALSE}
## inputFile. You can select your file.
inputFile      <- "/net/cn-1/mnt/SCRATCH/bio326-21/bio326_2022/AnimalGenomics/92/sequencing_summary_92.txt"
sequencedata <- data.table::fread(inputFile, stringsAsFactors=FALSE)

# You may want to change them.
flowcellId     <- "FAK41706" # example  "FAK41706"
basecaller     <-  "Guppy" # example "Guppy 2.1.3"
```


The summary dataset contains too much information.
We will calculate and extract core info.
(You can take a look the summary file by putting the follwing path in "Terminal" tub).

```{bash, eval=FALSE}
more /net/cn-1/mnt/SCRATCH/bio326-21/bio326_2022/AnimalGenomics/92/sequencing.summary_92.txt
```


![](assets/Bio326-2022/prep5.png){width=80%}

### Extract and organize the information
```{r, eval=FALSE}
# remove the redundant headers from merged files
if (length(which(sequencedata[,1]=="filename")) > 0) {
  sequencedata <- sequencedata[-which(sequencedata[,1]=="filename"),]
}
# coerce the columns used in analytics into more appropriate data-types 
sequencedata$channel<-as.numeric(sequencedata$channel)
sequencedata$start_time<-as.numeric(sequencedata$start_time)
sequencedata$duration<-as.numeric(sequencedata$duration)
sequencedata$num_events<-as.numeric(sequencedata$num_events)
sequencedata$sequence_length_template<-as.numeric(sequencedata$sequence_length_template)
sequencedata$mean_qscore_template<-as.numeric(sequencedata$mean_qscore_template)

# passes_filtering is a useful flag; but there are examples of sequencing_summary.txt where this 
# is not present - https://github.com/a-slide/pycoQC/blob/master/pycoQC/data/sequencing_summary_1D_DNA_Albacore_1.2.1.txt
if (! "passes_filtering" %in% colnames(sequencedata)) {
  # set all of the reads to pass? apply a cutoff?
  sequencedata$passes_filtering <- TRUE
} else {
  sequencedata$passes_filtering <- as.logical(sequencedata$passes_filtering)
}

# create a separation of pass and fail sequences...
passedSeqs <- sequencedata[which(sequencedata$passes_filtering), ]
failedSeqs <- sequencedata[which(!sequencedata$passes_filtering), ]

#####################

# calculate key metrics
readCount <- formatC(nrow(sequencedata), big.mark=",")
totalBases = sum(sequencedata$sequence_length_template,na.rm=T)/10^9
passedBases = sum(passedSeqs$sequence_length_template,na.rm=T)/10^9
gigabases <- round(totalBases,2)

# prepare a data object to render a summary graphic
figures <- 3
df <- data.frame(
  x = cumsum(c(2, rep(6.5, figures-1))),
  y = rep(2, figures),
  h = rep(4, figures),
  w = rep(6, figures))

df$info <- c("flowcell", readCount, gigabases)
df$key <- c(flowcellId,"Reads produced", "gigabases called")
df$icon <- fontawesome(c('fa-qrcode', 'fa-filter', 'fa-file-text-o'))
df$colour <- rep("steelblue", figures)
```


# 1. Generate a summary figure 
```{r, eval=FALSE}
# and display the plot
ExecutiveSummaryValueBoxes <- ggplot(df, aes(x, y, height = h, width = w, label = key, fill = colour)) +
  geom_tile(fill = brewer.pal(9,"Blues")[7]) +
  geom_text(color = brewer.pal(9,"Blues")[3], hjust="left", nudge_y=-1.5, nudge_x=-2.6, size=5) +
  geom_text(label=df$info, size=10, color = brewer.pal(9,"Blues")[2], fontface = "bold", nudge_x=-2.6, hjust="left") +
  geom_text(label=df$icon, family='fontawesome-webfont', colour=brewer.pal(9,"Blues")[5], size=23, hjust="right", nudge_x=2.85, nudge_y=0.8) +
  coord_fixed() + 
  theme_void() +
  guides(fill = F)

# save
ggsave(file.path("Results", "Figure1.Summary.png"), plot=ExecutiveSummaryValueBoxes, device="png", units="cm", width=15, height=3, dpi=reportDPI)

```


### Result1
<details>
  <summary> **Click to display**</summary>      
  ![](assets/Bio326-2022/Figure1.Summary.png)

</details> 

# Question1
This sequence data is from a pig sample. Approximately how much coverage do you estimate you have gained?
If it were Fruit fly sample, how much coverage is it then?

<details>
  <summary> ** Hint1**</summary>      
 Coverage =	(Obtained sequenced bases) / (genome size)

</details> 


# 2. Generate a flowcell channel figure
```{r, eval=FALSE}
# create an empty read count container ... MinION or PromethION??

# https://gist.github.com/roblanf/df47b9748c3aae00809cc675aca79989
# build the map for R9.5 flowcell, as a long-form dataframe that translates
# channels into rows and columns on the flowcell. Good for plotting in R.
p1 = data.frame(channel=33:64, row=rep(1:4, each=8), col=rep(1:8, 4))
p2 = data.frame(channel=481:512, row=rep(5:8, each=8), col=rep(1:8, 4))
p3 = data.frame(channel=417:448, row=rep(9:12, each=8), col=rep(1:8, 4))
p4 = data.frame(channel=353:384, row=rep(13:16, each=8), col=rep(1:8, 4))
p5 = data.frame(channel=289:320, row=rep(17:20, each=8), col=rep(1:8, 4))
p6 = data.frame(channel=225:256, row=rep(21:24, each=8), col=rep(1:8, 4))
p7 = data.frame(channel=161:192, row=rep(25:28, each=8), col=rep(1:8, 4))
p8 = data.frame(channel=97:128, row=rep(29:32, each=8), col=rep(1:8, 4))

q1 = data.frame(channel=1:32, row=rep(1:4, each=8), col=rep(16:9, 4))
q2 = data.frame(channel=449:480, row=rep(5:8, each=8), col=rep(16:9, 4))
q3 = data.frame(channel=385:416, row=rep(9:12, each=8), col=rep(16:9, 4))
q4 = data.frame(channel=321:352, row=rep(13:16, each=8), col=rep(16:9, 4))
q5 = data.frame(channel=257:288, row=rep(17:20, each=8), col=rep(16:9, 4))
q6 = data.frame(channel=193:224, row=rep(21:24, each=8), col=rep(16:9, 4))
q7 = data.frame(channel=129:160, row=rep(25:28, each=8), col=rep(16:9, 4))
q8 = data.frame(channel=65:96, row=rep(29:32, each=8), col=rep(16:9, 4))

# long form as a data frame, i.e. map$channel[[1]] returns 33
channelMap = rbind(p1, p2, p3, p4, p5, p6, p7, p8, q1, q2, q3, q4, q5, q6, q7, q8)

hm.palette <- colorRampPalette(brewer.pal(9, 'Blues'), space='Lab') #RdPu, Oranges, Greens, YlOrRd, Purples

channelCounts <- as.data.frame(matrix(rep(0, 512), ncol=1))
channelCountRaw <- as.data.frame(table(unlist(sequencedata[, "channel"])), row.names=1)
channelCounts[row.names(channelCountRaw),] <- channelCountRaw[,1]
#channelMap <- cbind(channelMap[channelMap$channel,], frequency=channelCounts[channelMap$channel,])
channelMap <- merge(channelMap, channelCounts, by.x="channel", by.y=0)
colnames(channelMap)[4]<-"count"
channelMapMatrix <- reshape2::acast(channelMap, col ~ row, value.var = "count")

theme_update(plot.title = element_text(hjust = 0.5))

channel<-ggplot(channelMap, aes(x = row, y = col, fill = count)) +
  geom_tile() +
  geom_text(data=channelMap,aes(x=row, y=col,label=count,color=count),show.legend = F, size=4) +
  scale_x_discrete(breaks=NULL) +
  scale_y_discrete(breaks=NULL) +
  coord_equal() +
  scale_fill_gradientn(colours = hm.palette(100)) +
  scale_color_gradient2(low = hm.palette(100), high = hm.palette(1)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(title="Channel activity plot showing number of reads per flowcell channel") +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        legend.position="bottom",
        legend.key.width=unit(5.6,"cm"))

ggsave(file.path("Results", "Figure2.channel.png"), plot=channel, device="png", units="cm", width=15, height=12, dpi=reportDPI)

```


### Result2
<details>
  <summary> **Click to display**</summary>      
  ![](assets/Bio326-2022/Figure2.Channel.png)

</details> 

# Question2
QQQ
<details>
  <summary> ** Hint2**</summary>      
HHH
</details> 


# 3. generate a read-length figure
```{r,eval=FALSE}
lenSorted <- rev(sort(passedSeqs$sequence_length_template))
passedMeanLength = round(mean(lenSorted), digits = 0)
N50 <- lenSorted[cumsum(lenSorted) >= sum(lenSorted)*0.5][1]
passedMeanQ = round(mean(passedSeqs$mean_qscore_template), digits = 1)
failedMeanQ = round(mean(failedSeqs$mean_qscore_template), digits = 1)

figures <- 5

df <- data.frame(
  x = cumsum(c(2, rep(6.5, figures-1))),
  y = rep(2, figures),
  h = rep(4, figures),
  w = rep(6, figures))

df$info <- c(passedMeanLength, N50, passedMeanQ, failedMeanQ, prettyNum(max(passedSeqs$sequence_length_template), big.mark=","))
df$key <- c("Mean Read Length (nt)","N50","Mean Read Quality (QV)","Mean Failed QV","Longest Read")
df$icon <- fontawesome(c("fa-bar-chart", "fa-play", "fa-area-chart", "fa-bug", "fa-sort"))

df$colour <- rep("steelblue", figures)

ReadCharacteristicsValueBoxes <- ggplot(df, aes(x, y, height = h, width = w, label = key, fill = colour)) +
  geom_tile(fill = brewer.pal(9,"Blues")[7]) +
  geom_text(color = brewer.pal(9,"Blues")[3], hjust="left", nudge_y=-1.5, nudge_x=-2.6, size=3.5) +
  geom_text(label=df$info, size=5.5, color = brewer.pal(9,"Blues")[2], fontface = "bold", nudge_x=-2.6, hjust="left") +
  geom_text(label=df$icon, family='fontawesome-webfont', colour=brewer.pal(9,"Blues")[5], size=13.3, hjust="right", nudge_x=2.85, nudge_y=0.8) +
  coord_fixed() + 
  scale_fill_brewer(type = "qual",palette = "Dark2") +
  theme_void() +
  guides(fill = F)

roundUpNice <- function(x, nice=seq(from=1, to=10, by=0.25)) {
  if(length(x) != 1) stop("'x' must be of length 1")
  10^floor(log10(x)) * nice[[which(x <= 10^floor(log10(x)) * nice)[[1]]]]
}

upperLimit <- roundUpNice(as.numeric(quantile(x=sequencedata$sequence_length_template, probs=c(0.975))))

histogramBinCount <- 40
breakVal = roundUpNice(upperLimit / histogramBinCount)
breaks <- seq(0, to=upperLimit, by=breakVal)
binAssignments <- cut(sequencedata$sequence_length_template, breaks, eval.lowest=TRUE, right=FALSE)

scrapeBinnedBases <- function(level, qcpass) {
  sum(subset(sequencedata[which(binAssignments == level), ], passes_filtering==qcpass)$sequence_length_template)
}

passedBinnedBases <- unlist(lapply(levels(binAssignments), scrapeBinnedBases, qcpass=TRUE))
failedBinnedBases <- unlist(lapply(levels(binAssignments), scrapeBinnedBases, qcpass=FALSE))
binnedBaseDist <- data.frame(length=head(breaks, -1), pass=passedBinnedBases, fail=failedBinnedBases)
binnedBaseMelt <- reshape2::melt(binnedBaseDist, id.vars=c("length"))

length<-ggplot(binnedBaseMelt, aes(x=length, fill=variable, y=value)) +
  geom_bar(stat="identity") +
  xlab("Read length\n") + ylab("Number of bases sequenced\n") +
  scale_fill_manual("QC", values=c("fail"=brewer.pal(6, "Paired")[1], "pass"=brewer.pal(6, "Paired")[2])) +
  scale_x_continuous(limits=c(-breakVal,upperLimit), breaks=pretty(passedSeqs$sequence_length_template,n=40)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(title="Histogram showing the number of sequenced bases against sequence length", fill="QV filter")+
  geom_vline(xintercept = N50, size = 1) +
  annotate("text", x=N50, y=max(passedBinnedBases + failedBinnedBases), label = " N50", hjust=0, colour="SteelBlue") +
  geom_vline(xintercept = passedMeanLength, size = 1) +
  annotate("text", x=passedMeanLength, y=max(passedBinnedBases + failedBinnedBases), label = " Mean", hjust=0, colour="SteelBlue")

ggsave(file.path("Results", "Figure3.length.png"), plot=length, device="png", units="cm", width=12, height=8, dpi=reportDPI)
```


### Result3
<details>
  <summary> **Click to display**</summary>      
  ![](assets/Bio326-2022/Figure3.length.png)

</details> 

# Question3
QQQ
<details>
  <summary> ** Hint3**</summary>      
HHH
</details> 


# 4. generate a sequence-time figure
```{r,eval=FALSE}
sequencedata$start_time <- sequencedata$start_time - min(sequencedata$start_time)
sequencedata$start_time <- sequencedata$start_time / scaling

# a 48 hour run, 5 minute intervals
sampleHours = 48
sampleIntervalMinutes = 60

breaks = seq(0, sampleHours*60*60, by=60*sampleIntervalMinutes)
binass <- findInterval(sequencedata$start_time, breaks)

mergeItPerHour <- function(interval, binnedAssignments, filter) {
  totalbases = 0
  if (length(which(binnedAssignments==interval))>0) {
    subset <- sequencedata[which(binnedAssignments==interval), ]
    if (length(which(subset$passes_filtering == filter)) > 0) {
      totalbases = sum(subset[which(subset$passes_filtering == filter), "sequence_length_template"])
    }
  }
  # need to scale what is being returned - totalbases value is total bases within an interval (sampleIntervalMinutes)
  return(totalbases / 1e9 / sampleIntervalMinutes * 60)
}

binnedTemporalDataPerHour <- data.frame(
  cbind(
    time=breaks,
    pass=unlist(lapply(seq(breaks), mergeItPerHour, binnedAssignments=binass,filter=TRUE)),
    fail=unlist(lapply(seq(breaks), mergeItPerHour, binnedAssignments=binass, filter=FALSE))
  )
)

binnedTemporalDataPerHour$time <- binnedTemporalDataPerHour$time / 60 / 60

time<-ggplot(binnedTemporalDataPerHour, aes(time)) +
  geom_line(aes(y = fail, colour = "fail"), size=1) + 
  geom_line(aes(y = pass, colour = "pass"), size=1) +
  scale_color_manual(name="QV", values=c("fail"=brewer.pal(6, "Paired")[1], "pass"=brewer.pal(6, "Paired")[2])) +
  xlab("Time (hours)") + 
  ylab("Gigabases sequenced per hour") + 
  labs(title="Plot showing sequence throughput against time")

ggsave(file.path("Results", "Figure4.time.png"), plot=time, device="png", units="cm", width=12, height=8, dpi=reportDPI)
```



### Result4
<details>
  <summary> **Click to display**</summary>      
  ![](assets/Bio326-2022/Figure4.time.png)

</details> 

# Question4
QQQ
<details>
  <summary> ** Hint4**</summary>      
HHH

</details> 

